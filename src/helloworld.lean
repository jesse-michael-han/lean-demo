import tactic
import data.nat.parity
import system.io

section warm_up

variables {α β : Type} (p q : α → Prop) (r : α → β → Prop)

lemma exercise_1 : (∀ x, p x) ∧ (∀ x, q x) → ∀ x, p x ∧ q x :=
begin
  intro H, intro x, refine ⟨_,_⟩,
  cases H with Hp Hq, exact Hp x,
  cases H with Hp Hq, exact Hq x
end

#check exercise_1

#check Prop

#check Type

#print and

-- blast our way to the end

example : (∀ x, p x → q x) → (∀ x, p x) → ∀ x, q x := by finish

example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := by finish

example : (∃ x, p x ∧ q x) → ∃ x, p x := by finish

example : (∃ x, ∀ y, r x y) → ∀ y, ∃ x, r x y := by tidy

end warm_up

/-
We're going to solve a simplified version of the `coffee can problem`, due to David Gries' `The Science of Programming` (note: really good read).

Suppose you have a coffee can filled with finitely many white and black beans. You have an infinite supply of white and black beans outside the can.

Carry out the following procedure until there is only 1 bean left in the can:

 - Draw two beans
   - if their colors are different (i.e. (white, black) or (black, white)), then you discard the white one and return the black one.
   - if their colors are the same, discard both of them and you add a white bean to the can.

Prove that this process terminates with a single white bean iff the number of black beans is even.

We're going to solve this problem where the coffee can is a list and we only pop and push beans from the head of the list.
-/

/-
  To state this problem , we need:
     - [x] a notion of beans
     - [x] define the "coffee operation"
     - [ ] a way to count the number of white and black beans
     - [ ] a notion of evenness (I'm going to import this from mathlib).
-/

inductive beans : Type
| white : beans
| black : beans

#print beans.cases_on

open beans -- this opens the namespace `beans` so we don't have to qualify the constructors

@[simp]
def coffee : list beans → list beans
| [] := []
| [b] := [b]
| (white::white::bs) := coffee (white::bs)
| (white::black::bs) := coffee (black::bs)
| (black::white::bs) := coffee (black::bs)
| (black::black::bs) := coffee (white::bs)

def some_beans : list beans := [white, black, white, black, black]

instance : has_repr beans :=
{ repr := λ b, beans.cases_on b "◽" "◾" }

#eval coffee (some_beans)


@[simp] -- by tagging this as simp, make all the equation lemmas generated by Lean
-- available to the simplifier
def count_beans : beans → list beans → ℕ
| b [] := 0
| white (white::bs) := count_beans white bs + 1
| white (black::bs) := count_beans white bs
| black (white::bs) := count_beans black bs
| black (black::bs) := count_beans black bs + 1

-- Lean has a powerful built-in simplifier tactic that has access to a global library of
-- `simp lemmas`. `simp` is essentially a confluent rewriting system.

lemma count_beans_is_not_horribly_wrong {xs} : count_beans white xs + count_beans black xs = xs.length :=
begin
  induction xs with hd tl IH,
    { refl },
    { cases hd,
      { simp, rw ← IH, omega }, -- omega will decide linear Presburger arith
      { simp, rw ← IH, omega } }
end

open nat -- open nat namespace to avoid qualifying imported defs

lemma coffee_lemma_1 {x : beans} {xs : list beans} : even (count_beans black (x::xs)) ↔ even (count_beans black $ coffee (x::xs)) :=
begin
  induction xs with hd tl IH generalizing x,
    { cases x; simp },
    { cases x; cases hd,
      all_goals {try {simp * at *}},
     have := @IH white, simp * with parity_simps at *,

    have := @IH black, simp * with parity_simps at *,

    have := @IH black, simp * with parity_simps at *,

    have := @IH white, simp * with parity_simps at * }
end

lemma coffee_lemma_2 {x : beans} {xs : list beans} : coffee (x::xs) = [white] ∨ coffee (x::xs) = [black] :=
begin
  induction xs with hd tl IH generalizing x,
    { cases x, simp, simp },
    { cases x; cases hd,
      all_goals { simp * at * }}
end

theorem coffee_can_problem {x : beans} {xs : list beans} :
  coffee (x::xs) = [white] ↔ even (count_beans black (x::xs)) :=
begin
  have H₁ : even (count_beans black (x::xs)) ↔ even (count_beans black $ coffee (x::xs)),
  by { apply coffee_lemma_1 },
  have H₂ : coffee (x::xs) = [white] ∨ coffee (x::xs) = [black],
  by { apply coffee_lemma_2 },
  cases H₂,
    { refine ⟨_,_⟩,
       { intro H, rw H₁, rw H, simp },
       { intro H, assumption }},
    { 
    refine ⟨_,_⟩,
      { intro H_bad, exfalso, cc }, -- cc is the congruence closure tactic
                                    -- chains together equalities and knows
                                    -- how to reach simple contradictions
                                    -- involving constructors
      { intro H, exfalso, rw H₁ at H, rw H₂ at H, simp at H, exact H }}
end

def coffee2 : list beans → list beans := λ bns,
match bns with
| [] := []
| bns := let num_black_beans := count_beans black bns in
         if (even num_black_beans) then [white] else [black]
end

theorem coffee_coffee2 : coffee = coffee2 :=
begin
  funext bns, cases bns,
    { simp[coffee2] },
    { by_cases H : even (count_beans black $ bns_hd :: bns_tl),
      { simp [coffee2, *], rwa ← coffee_can_problem at H },
      { simp [coffee2, *], rw ← coffee_can_problem at H, finish using coffee_lemma_2 }}
end

namespace tactic
namespace interactive
namespace tactic_parser

section metaprogramming

@[reducible]meta def tactic_parser : Type → Type := state_t string tactic

meta def tactic_parser.run {α} : tactic_parser α → string → tactic α :=
λ p σ, prod.fst <$> state_t.run p σ

meta def parse_char : tactic_parser string :=
{ run := λ s, match s with
              | ⟨[]⟩ := tactic.failed
              | ⟨(c::cs)⟩ := prod.mk <$> return ⟨[c]⟩ <*> return ⟨cs⟩
              end }

meta def failed {α} : tactic_parser α := {run := λ s, tactic.failed}

meta def parse_bean : tactic_parser beans :=
do c ← parse_char,
   if c = "1" then return white else
   if c = "0" then return black else failed

meta def repeat {α} : tactic_parser α → tactic_parser (list α) :=
λ p, (list.cons <$> p <*> repeat p) <|> return []

meta instance format_of_repr {α} [has_repr α] : has_to_tactic_format α :=
{ to_tactic_format := λ b,
    return (let f := (by apply_instance : has_repr α).repr in format.of_string (f b))}

run_cmd ((repeat parse_bean).run "101010111001" >>= tactic.trace)

-- #eval some_more_beans

end metaprogramming
end tactic_parser
end interactive
end tactic

/-
  Some set theory, using Aczel sets (see mathlib's set_theory/zfc.lean for a more thorough development, or Flypitch for a Boolean-valued version)
-/
universe u

inductive pSet : Type (u+1) -- Aczel sets
| mk (α : Type u) (A : α → pSet)

namespace pSet

def eqv : pSet → pSet → Prop
| (⟨α, A⟩) (⟨α', A'⟩) := (∀ a : α, ∃ a' : α', eqv (A a)  (A' a')) ∧ (∀ a' : α', ∃ a : α, eqv (A a) (A' a'))

def mem : pSet → pSet → Prop
| x (⟨α, A⟩) := ∃ a : α, eqv x (A a)

infix `∈ˢ`:1024 := pSet.mem
infix `=ˢ`:1024 := pSet.eqv

end pSet

-- this proof actually doesn't use anything and just works for any binary relation
-- lemma russell (x : pSet.{u}) (Hx : (∀ y : pSet.{u}, (y ∈ˢ x ↔ (¬ y ∈ˢ y)))): (x ∈ˢ x) ∧ (¬ x ∈ˢ x) :=
-- begin
--   refine ⟨_,_⟩,
--   { classical, by_contradiction, have := (Hx x).mpr ‹_›, contradiction },
--   { classical, by_contradiction, have := (Hx x).mp ‹_›, contradiction }
-- end

-- indeed
lemma russell_aux {α : Type*} {mem : α → α → Prop} {x : α} (Hx : (∀ a : α, mem a x ↔ ¬ mem a a)) : mem x x ∧ ¬ mem x x :=
begin
  refine ⟨_,_⟩,
  { classical, by_contradiction, have := (Hx x).mpr ‹_›, contradiction },
  { classical, by_contradiction, have := (Hx x).mp ‹_›, contradiction }  
end

lemma russell (x : pSet.{u}) (Hx : (∀ y : pSet.{u}, (y ∈ˢ x ↔ (¬ y ∈ˢ y)))): (x ∈ˢ x) ∧ (¬ x ∈ˢ x) := russell_aux ‹_›

@[simp]lemma eqv_refl {x : pSet} : x =ˢ x := by induction x; tidy

lemma eqv_trans {x y z : pSet} (H₁ : x =ˢ y) (H₂ : y =ˢ z) : x =ˢ z :=
begin
  induction x with α₁ A₁ generalizing y z, induction y with α₂ A₂, induction z with α₃ A₃,
  cases H₁ with H₁_left H₁_right, cases H₂ with H₂_left H₂_right,
  refine ⟨_,_⟩; intro i,
    { cases H₁_left i with j Hj, cases H₂_left j with k Hk,
      refine ⟨k, _⟩, apply x_ih, exact Hj, exact Hk, },
    { cases H₂_right i with j Hj, cases H₁_right j with k Hk,
      refine ⟨k, _⟩, apply x_ih, exact Hk, exact Hj }
end

lemma eqv_symm {x y : pSet} (H : x =ˢ y) : y =ˢ x :=
begin
  induction x with α A generalizing y, induction y with α' A' generalizing α A,
  refine ⟨_,_⟩; intro i; cases H with H₁ H₂,
    { specialize H₂ i, cases H₂ with a Ha, use a, finish },
    { specialize H₁ i, cases H₁ with a' Ha', use a', finish }
end

lemma eqv.symm {x y} : x =ˢ y ↔ y =ˢ x := ⟨eqv_symm, eqv_symm⟩

@[simp]lemma mem_congr_right {x y z : pSet} (H_mem : x ∈ˢ y) (H_eqv : y =ˢ z) : x ∈ˢ z :=
begin
  induction y with α A, induction z with β B,
  cases H_eqv with H₁ H₂, cases H_mem with a Ha,
  cases H₁ a with b Hb, use b, exact eqv_trans Ha Hb
end

@[simp]lemma mem_congr_left {x y z : pSet} (H_mem : x ∈ˢ y) (H_eqv : x =ˢ z) : z ∈ˢ y :=
begin
  induction y with α A, cases H_mem with a' Ha', use a', exact eqv_trans (eqv_symm H_eqv) ‹_›
end

@[simp]lemma mem.mk {α : Type u} {a : α} {A : α → pSet.{u}} : A a ∈ˢ (pSet.mk α A : pSet.{u}) := ⟨a, by simp⟩

lemma mem_iff {x y : pSet.{u}} : x ∈ˢ y ↔ ∃ z : pSet.{u}, z ∈ˢ y ∧ x =ˢ z :=
begin
  refine ⟨_,_⟩; intro H,
    { cases y with α A, cases H with a_x H_a_x,
      refine ⟨A a_x, ⟨_,_⟩⟩,
        { simp },
        { assumption }},
    { rcases H with ⟨z, ⟨Hz₁, Hz₂⟩⟩, apply mem_congr_left ‹_›, exact eqv_symm ‹_› }
end

-- technically a consequence of foundation
lemma foundation {x} : x ∈ˢ x → false :=
begin
  intro H_mem_self, induction x with α A,
  rcases H_mem_self with ⟨a, Ha⟩, apply x_ih a,
  exact mem_congr_right (mem.mk) ‹_›
end

-- run this file with `lean --run hello_world.lean`
def main : io unit :=
do trace (string.join ((by apply_instance : has_repr beans).repr <$> [white, black, white, black, black, black, white])) (return ()),
   trace ("Hello world!") (return ())
